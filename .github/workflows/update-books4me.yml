name: æ›´æ–°books4meç›®å½•ä¹¦ç±åˆ—è¡¨

on:
  push:
    paths:
      - 'books4me/*.html'
      - 'books4me/**/*.html'
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'

jobs:
  update-books4me-list:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: è®¾ç½® Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: ç”Ÿæˆä¹¦ç±åˆ—è¡¨ï¼ˆbooks4meç›®å½•ï¼‰
        run: |
          cat > generate_books4me.py << 'EOF'
          # ä»£ç é€»è¾‘å’Œä¸Šé¢å®Œå…¨ä¸€è‡´ï¼Œä»…ä¿®æ”¹ books_dir = 'books4me'
          import os
          import json
          import time
          import glob
          
          def get_category_icon(category):
              icons = {'ç«¥è¯':'ğŸ§š', 'ç§‘å¹»':'ğŸš€', 'æ–‡å­¦':'ğŸ“š', 'å†å²':'ğŸ›ï¸', 'å“²å­¦':'ğŸ¤”', 'è¯—æ­Œ':'ğŸ­', 'ä¼ è®°':'ğŸ“œ', 'æŠ€æœ¯':'ğŸ’»', 'è‰ºæœ¯':'ğŸ¨', 'æ•™è‚²':'ğŸ“–'}
              return icons.get(category, 'ğŸ“˜')
          
          def parse_filename(filename):
              name = filename.replace('.html', '')
              category = 'æœªåˆ†ç±»'
              title = name
              author = ''
              if '_' in name:
                  parts = name.split('_')
                  if len(parts)>=2: category, title = parts[0], parts[1]
                  if len(parts)>=3: author = parts[2]
              return {'category':category, 'title':title, 'author':author}
          
          def get_file_time(filepath):
              try:
                  import subprocess
                  result = subprocess.run(['git', 'log', '-1', '--format=%ct', filepath], capture_output=True, text=True)
                  if result.returncode ==0 and result.stdout.strip():
                      return int(result.stdout.strip())*1000
              except: pass
              return int(os.path.getmtime(filepath)*1000)
          
          def main():
              books_dir = 'books4me'  # é‡ç‚¹ï¼šå¯¹åº”books4meç›®å½•
              if not os.path.exists(books_dir):
                  os.makedirs(books_dir)
                  empty_data = {'lastUpdated':int(time.time()*1000), 'totalBooks':0, 'totalCategories':0, 'categories':[], 'books':[], 'categoryStats':[]}
                  with open(f'{books_dir}/books.json', 'w', encoding='utf-8') as f:
                      json.dump(empty_data, f, ensure_ascii=False, indent=2)
                  return
              
              all_books = []
              html_files = glob.glob(f'{books_dir}/**/*.html', recursive=True)
              for filepath in html_files:
                  filename = os.path.basename(filepath)
                  if filename == 'index.html': continue
                  rel_path = os.path.relpath(filepath, books_dir).replace('\\', '/')
                  parsed = parse_filename(filename)
                  stat = os.stat(filepath)
                  file_time = get_file_time(filepath)
                  book = {
                      'id':filename, 'file':rel_path, 'filename':filename,
                      'title':parsed['title'], 'category':parsed['category'], 'author':parsed['author'],
                      'size':stat.st_size, 'lastModified':file_time, 'addedTime':file_time
                  }
                  all_books.append(book)
              
              # æŒ‰ä¹¦åæ’åº
              all_books.sort(key=lambda x: x['title'])
              
              # æŒ‰åˆ†ç±»ç»Ÿè®¡ï¼ˆä¼˜åŒ–é€»è¾‘ï¼Œå¯è¯»æ€§æ›´é«˜ï¼‰
              categories = {}
              for book in all_books:
                  cat = book['category']
                  if cat not in categories:
                      categories[cat] = []
                  categories[cat].append(book)  # ä¼˜åŒ–ç‚¹ï¼šæ›¿æ¢æ‹¼æ¥åˆ—è¡¨çš„æ–¹å¼
              
              # ç”Ÿæˆæœ€ç»ˆæ•°æ®
              output_data = {
                  'lastUpdated':int(time.time()*1000), 'totalBooks':len(all_books), 'totalCategories':len(categories),
                  'categories':list(categories.keys()), 'books':all_books,
                  'categoryStats':[
                      {'name':cat, 'count':len(books), 'icon':get_category_icon(cat)} 
                      for cat, books in categories.items()
                  ]
              }
              
              # å†™å…¥books.json
              with open(f'{books_dir}/books.json', 'w', encoding='utf-8') as f:
                  json.dump(output_data, f, ensure_ascii=False, indent=2)
              
              print(f'âœ… books4meç›®å½•ç”Ÿæˆå®Œæˆï¼š{len(all_books)} æœ¬ä¹¦ï¼Œ{len(categories)} ä¸ªåˆ†ç±»')
          
          if __name__ == '__main__':
              main()
          EOF
          
          python3 generate_books4me.py
      
      - name: æäº¤æ›´æ”¹ï¼ˆbooks4meç›®å½•ï¼‰
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          # ä¼˜åŒ–ï¼šè®¾ç½®ä¸Šæ¸¸åˆ†æ”¯ + å®¹é”™ï¼Œé¿å…pullæŠ¥é”™
          git checkout ${{ github.ref_name }} || git checkout main
          git pull origin ${{ github.ref_name }} --rebase --set-upstream || git pull origin main --rebase
          git add books4me/books.json
          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹ï¼Œæœ‰åˆ™æäº¤
          git diff --quiet && git diff --staged --quiet || git commit -m "ğŸ¤– è‡ªåŠ¨æ›´æ–°books4meç›®å½•ä¹¦ç±åˆ—è¡¨ [skip ci]"
          # æ¨é€ï¼ˆå¢åŠ å®¹é”™ï¼Œå¤±è´¥é‡è¯•ä¸€æ¬¡ï¼‰
          git push || git push --force-with-lease
